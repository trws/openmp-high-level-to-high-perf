\section{Future Directions}
\label{sec:future_directions}

\subsection{Device Extensions}
\label{sub:device_extensions}

\subsection{Enabling Language-Level Outlining}
\label{sub:enabling_language_level_outlining}

As we discussed in Section~\ref{sub:outlining} outlining, or extraction of code
into functions by the compiler, is one of the core mechanisms used by OpenMP.
Some languages provide a mechanism for this directly in the form of closures or,
at least in the case of C++, lambdas.  The attraction of these constructs,
especially for the writers of libraries and parallel frameworks, comes from the
fact that they allow abstract patterns and behaviors to be implemented once
while giving users the ability to pass an arbitrarily complex bit of code and
associated data into the pattern to be executed.  Much of OpenMP could be
implemented as a library in modern C++, if with less guarantees to the compiler
and less flexibility given to the implementer, with the use of lambdas.
Frameworks like Kokkos~\cite{kokkos} and RAJA~\cite{raja} exploit this mechanism
to create flexible looping constructs, like the one in Figure~\ref{fig:raja},
that can be compiled for host devices, targets or any number of parallel
backends depending on compile time arguments.

\begin{figure}
\begin{minted}{c}
RAJA::forall<omp_parallel_for>(
    RAJA::range(0,N),
    [=](int a) {
      // loop body
});
\end{minted}
\caption{A C++ lambda supplying the loop body for a parallel for loop}
\label{fig:raja}
\end{figure}
   
Up to this point OpenMP implementations have commonly used outlining as a way to
implement the requirements of the specification, but the resulting functions
have never been exposed to the user as something they could rely on or call.
Given how useful lambdas have proven however, it may be time to change that.
We're investigating the possibility of extending the \texttt{task} directive to
make it possible to create a form of "callable task" or OpenMP closure object
that would be portable across C, C++ and Fortran.  The advantage of this would
be a major reduction in the amount of work it takes to make an arbitrary
callable object with state in C and Fortran, and allow libraries to be
implemented that would provide functionality like that of Kokkos and RAJA to all
three languages.  Challenges remain however, particularly how to integrate the
functionality well into OpenMP and how to make it as efficient as possible at
runtime.  The simple solution of generating a structure, or derived type, and
a function pointer is quite portable and would integrate well with established
libraries, but is unlikely to optimize well for constructs that will be called
many times.  Despite the challenges, giving users control of outlining could be
a major step forward for OpenMP.

\subsection{Iterators}
\label{sub:iterators}

One emerging need in the usage of OpenMP is the ability to increase the dynamic
nature of OpenMP description (its effects are mostly dynamic). For example, the
depend clause allows to express that a task or a target construct has
a dependence on different elements of an array. You can express this today by
writing multiple clauses which can easily become tedious and error prone if it
is more than a few clauses. Furthermore, if the number of clauses would depend
on a runtime decision, like if this is a corner cell or an inner cell, it would
be impossible to describe in a single directive. The same reasoning could be
applied to the map clause in target directives where you would like to describe
different elements of an array.
   
To overcome this lack of expressiveness OpenMP iterators are being developed.
They allow to iterate through a range of values and evaluate the same clause
multiple times with each value in the range. Furthermore, this range can be
described at runtime which allows to vary both the number clauses and their
content for a given directive. Figure~\ref{fig:iterators} shows how the iterator
feature can be used to express a variable number of dependences on a \emph{task}
construct.

\begin{figure}
\begin{minted}{c}
void func( double *a, int N )
{
#pragma omp task depend(inout:a[i]:i=0:N)
   work(a);
}
\end{minted}
\caption{Example of task dependencies with iterators}
\label{fig:iterators}
\end{figure}
   
One could see this as first step towards providing OpenMP with metaprogramming
capabilities that would allow were possibly to construct the directives either
at compile time or runtime instead of only allowing them to be statically typed
by a programmer.
   

