\subsection{Cancellation}
\label{sec:Cancellation}
OpenMP~4.0 introduced the concept of cancellation, a capability to end 
OpenMP regions \emph{early}. This capability enables efficient error
handling but also supports more efficient search algorithms. When a thread
encounters a \texttt{cancel} construct, it cancels execution of the 
inner-most associated region (as indicated by a \texttt{parallel}, 
\texttt{sections}, \texttt{for} or \texttt{do} clause) or associated set 
of tasks (as indicated by the the \texttt{taskgroup} clause). 

Cancellation must occur with well-defined semantics so users can ensure 
that their data is in an expected state. Since the user can manage the 
state immediately before the \texttt{cancel} construct, the thread 
that encounters it immediately proceeds to the end of the canceled region 
(e.g., the end of the current task for the \texttt{taskgroup} clause). Other
threads must encounter a \emph{cancellation point}, prior to which the user 
can manage state, in order to process the cancellation. Cancellation points 
are implied at barriers and are explicitly indicated by a 
\texttt{cancellation point} or \texttt{cancel} construct. If a thread observes 
that another thread has canceled the associated region at a cancellation point,
it also proceeds to the end of the canceled region (e.g., the end of the 
current task). With the \texttt{taskgroup} clause, tasks that have not begun
to execute are simply discarded since they cannot have state from partial 
execution.

Figure~\ref{fig:Cancellation} shows how to cancel a binary tree search when 
the value is found. Without the OpenMP directives, the code recursively 
examines children nodes and stops if the value of the current tree node 
matches the search value. With OpenMP tasking, the subtree searches execute
in parallel. Without cancellation, once a tasks find search value, it will 
not generate any more tasks but the other branches of the parallel search 
will continue. With cancellation, any executing tasks will complete their 
check but any generated tasks that have not begun execution (including those 
generated by those executing tasks) are discarded so that unnecessary work 
is greatly reduced while still executing the search in parallel.

\begin{figure}
\begin{minted}{c}
bin_tree_t *
search_tree(bin_tree_t * tree, int val) {
  bin_tree_t * found = NULL;
  if (tree) {
    if (tree->val == val)
      found = tree;
    else {
#pragma omp task shared(found)
      {
        bin_tree_t * found_left =
          search_tree(tree->left, val);
        if (found_left) {
#pragma omp atomic write
          found = found_left;
#pragma omp cancel taskgroup
        }
      }
#pragma omp task shared(found)
      {
        // similar code for right branch
      }
#pragma omp taskwait
    }
  }
  return found;
}
\end{minted}
\caption{Cancellation Example\label{fig:Cancellation}}
\end{figure}


