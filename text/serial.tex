\subsection{Serial Equivalence}
\label{sub:serial_equivalence}

A original goal for OpenMP was to support serial equivalence to the 
greatest possible extent. As a result, many think that all OpenMP programs, 
or at least all correct OpenMP programs, are guaranteed the same result
if the code is executed in parallel as when the compiler completely 
ignores all OpenMP constructs. However, even OpenMP 1.0 included runtime
functions that allow a program to depend on the number of threads or the
thread number (or ID) that executed a region. Thus, trivial programs could
fail to exhibit serial equivalence. Today, many more opportunities exist
to write OpenMP programs that do not provide serial equivalence. 

%% BRONIS: STOPPED EDITING HERE
%% BRONIS: NEED TO PROVIDE MORE COMPLETE DISCUSSION OF PHILOSOPHY
%% BRONIS: SHOULD PROVIDE ACTUAL EXAMPLES IN (PSEUDO) CODE

All OpenMP constructs make it possible to write a program with
serial equivalence, but it is equally possible to write correct, well-formed
programs that get different answers not only between sequential and parallel but
also for any given number of threads.
The reason for this is that OpenMP provides information to the user about how
their code is being run and attempts to offer high performance by default, and
serial equivalence if needed.  Given code that avoids doing anything based on 
the number of threads, there are still two factors that can create programs 
without serial equivalence: data privatization and execution order.  For 
example, a
workshared loop with a reduction clause makes no guarantee of the order in which
the intermediate products are combined.  This makes it both non-deterministic
and non-serial-equivalent for any reduction over floating point numbers.

Serial equivalence will continue to be possible in OpenMP for the foreseeable
future, but as the specification grows and more control is given to the user,
the number of ways to write code without serial equivalence also grows.

