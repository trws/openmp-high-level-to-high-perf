\section{Philosophy}
\label{sec:philosophy}


\tom{Bronis, Tim, please look this part over especially}

The general philosophy of OpenMP is to provide a portable, expressive
programming model for parallel and concurrent programming that allows a user to
keep their code as close to the original serial version as possible while still
achieving performance goals.

\subsection{Serial Equivalence}
\label{sub:serial_equivalence}

A common misconception about OpenMP is that all OpenMP programs, or at least all
correct OpenMP programs, provide serial equivalence. In this case serial
equivalence refers to a guarantee that if a program is compiled with all OpenMP
constructs completely ignored it will get the same answer as both the original
serial code and the OpenMP code in parallel.  The truth is significantly more
complicated.  All OpenMP constructs make it possible to write a program with
serial equivalence, but it is equally possible to write correct, well-formed
programs that get different answers not only between sequential and parallel but
also for any given number of threads.

The reason for this is that OpenMP provides information to the user about how
their code is being run and attempts to offer high performance by default, and
serial equivalence if needed.  It is possible to write code that depends on the
number of threads by using runtime routines to query the thread count and the
identity of a given thread.  Given code that avoids doing anything based on the
number of threads, there are still two factors that can create programs without
serial equivalence: data privatization and execution order.  For example, a
workshared loop with a reduction clause makes no guarantee of the order in which
the intermediate products are combined.  This makes it both non-deterministic
and non-serial-equivalent for any reduction over floating point numbers.

Serial equivalence will continue to be possible in OpenMP for the foreseeable
future, but as the specification grows and more control is given to the user,
the number of ways to write code without serial equivalence also grows.

\subsection{Language Independence}
\label{sub:language_independence}

Though OpenMP began with separate specifications for C and Fortran, the decision
was made early on to merge the two into a single document and push both base
languages forward together.  This draws to one of the core philosophies, and
arguably core strengths, of OpenMP as a model which is its portability and
compatibility across C, C++ and Fortran.  For scientific codebases, especially
those with long lived legacy code, this can be a significant advantage.  

\tom{this is too short, ideas on how to expand?}

\subsection{Relationship to the Base Language}
\label{sub:relationship_to_the_base_language}

OpenMP, by itself, is not a language.  It provides an API for expressing
parallelism and concurrency in a portable way across three independent
languages, with the goal of providing the same experience and easy
interoperability between all three.  Because of this it relies heavily on each
base language to define the behavior of a given construct within each thread of
execution or block of code.  The relationship with the base languages has
changed somewhat over time however.  Before the release of C11 and C++11, C and
C++ themselves had no well-defined concept of a data race, or of threading in
general.  In fact, the ISO C99 standard~\cite{c99} does not contain the word
"thread" at all, and contains the word "race" only as part of the word "brace."
As a result, OpenMP has to provide all threading and memory model semantics for
a program written using OpenMP constructs in the context of a C99 program.  With
the advent of integrated threading models, acquire and release memory models and
more built-in parallel concepts OpenMP is now in a position of providing its own
semantics in the context of those models and integrating with them.


