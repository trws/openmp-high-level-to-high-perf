\subsection{Device Extensions}
\label{sub:device_extensions}

While OpenMP introduced support for offloading to target devices in version 4.0
and subsequently expanded on the support significantly in 4.5, the space is
changing quickly and many more extensions and refinements are in the works for
5.0.  Quite possibly the biggest shifts have been in how memory is managed,
where more and more devices support a unified cache-coherent memory space
while others continue to require explicit memory management to function.
Bridging this gap to allow for both cases has become critical for portability
and for productivity.  Two features are in the works, each to address
programmability on one of the two types of systems, each without preventing use
of the other.


Many offload models, such as CUDA and OpenCL, require function annotations. 
However, OpenMP 5.0 will ease the use of functions in device code by relaxing 
its annotation requirements. Specifically, OpenMP 5.0 eliminates the 
requirement to annotate function declarations. Essentially, the compiler 
must assume that a device variant will be available at link time. Further, 
the compiler must automatically generate a device variant for any function 
with a definition in the same translation unit as a call from a 
\texttt{target} region on that device. Essentially, the definition implicitly 
includes the \texttt{declare target} annotation. Because these changes 
significantly improve usability, several compilers have already implemented 
them and they have allowed entire large codebases (particularly in C++ 
due to the pervasiveness of templates) to offload to devices with OpenMP 
without a single explicit \emph{declare target} directive while other 
models require hundreds or thousands of annotations to compile at all.

First, in order to make use of coherent memory between the host and a target
device, the user needs a way to assert to the compiler that they expect that
behavior, and that they only intend to run on hardware that can provide it.  To
address this need, OpenMP is going to include a new directive called
\texttt{requires} that allows OpenMP, or a vendor, to specify a set of rules for
a given requirement and users to specify that their code will only function
correctly if those requirements are met.  This way, conforming subsets of the
OpenMP specification can be defined, and the first one will be to support
systems that do not require memory to be explicitly mapped into a data
environment for target devices.  For example, the code in
Figure~\ref{fig:unified} is only valid for systems with a unified view of
memory, and is non-conforming in OpenMP up to 4.5, but with the requirement it
becomes a conforming program for implementations that can meet the requirement.

\begin{figure}
\begin{minted}{c}
#pragma omp requires \
        unified_shared_memory
struct list {
  void *data;
  struct list *next;
};

void foo() {
  struct list *l = make_linked_list();
#pragma omp target
  {
    struct list *cur;
    while(cur) {
      do_something_with_data(cur->data);
      cur = cur->next;
    }
  }
}
\end{minted}
\caption{How to \texttt{require} a Unified Memory Space}
\label{fig:unified}
\end{figure}

The second feature addresses handling complex data structures, like the linked
list in Figure~\ref{fig:unified}, on systems that don't or can't provide
coherent unified memory.  As of OpenMP 4.5, the only way to make such structures
work is to map each individual piece of the structure and to fix up pointers as
necessary on the device either with explicit assignments or by using mapping
constructs to attach them.  This process is verbose, complex and error prone for
large and complex structures, and to make matters worse it mas to be replicated
throughout the code to have the desired effect in some codes.  To alleviate this
burden, we're developing a way for users to declare their own mappers, which are
descriptors for how to map a variable and all of its children or associated
data.  The \texttt{declare mapper} directive will allow existing map clauses
used to map the members of structures and attach pointers to be collected in
one place and re-used wherever they're needed.  Beyond that, each phase of the
mapping process will be replaceable with user-defined expressions or functions
written in the base language to allow for structures too complex to be handled
with existing constructs to be handled by serialization and deserialization as
they might be for transmission over a network.



